# file genHMM.py

import numpy as np
from hmmlearn.utils import normalize
from src.glow.models import Glow, FlowNet
from src.glow.config import JsonConfig
from hmmlearn.base import _BaseHMM
from functools import partial


class GenHMM(_BaseHMM):
    def __init__(self, n_components=None, n_prob_components=None, hparams=None,\
            algorithm="viterbi", random_state=None, n_iter=10, tol=1e-2, verbose=False, params="st", init_params="st",\
                 image_shape=(28, 28, 3)):

        _BaseHMM.__init__(self, n_components,
                          algorithm=algorithm, random_state=random_state, n_iter=n_iter,
                          tol=tol, params=params, verbose=verbose, init_params=init_params)
        self.image_shape=image_shape
        self.n_components = n_components
        self.n_prob_components = n_prob_components
        self.hparams = JsonConfig(hparams)

        self.model_params = ["transmat_", "startprob_", "networks", "pi"]

        self.init_transmat()
        self.init_startprob()
        self.init_gen()

        self.init_future()

        print("here")

    def init_startprob(self):
        """
        Initialize HMM initial coefficients.
        """
        init = 1. / self.n_components
        self.startprob_ = np.full(self.n_components, init)
        return self

    def init_transmat(self):
        """
        Initialize HMM transition matrix.
        """
        init = 1/self.n_components
        self.transmat_ = np.full((self.n_components, self.n_components),
                                 init)
        return self

    def init_gen(self):
        """
        Initialize HMM probabilistic model.
        """

        # Init latent selector variable
        self.pi = np.random.rand(self.n_components, self.n_prob_components)
        normalize(self.pi, axis=1)

        # Init networks

        self.networks = [Glow(self.hparams) for _ in range(self.n_prob_components*self.n_components)]
        #self.networks = [FlowNet(image_shape=self.image_shape,hidden_channels=5, L=2, K=2,\
        #                         flow_coupling="additive", flow_permutation="shuffle")\
        #                 for _ in range(self.n_prob_components * self.n_components)]

        self.networks = np.array(self.networks).reshape(self.n_components, self.n_prob_components)
        return self

    def llh(self, X):
        return self._compute_log_likelihood(X)


    def _compute_log_likelihood(self, X):
        """Computes per-component log probability under the model.

        Parameters
        ----------
        X : array-like, shape (n_samples, n_features)
            Feature matrix of individual samples.

        Returns
        -------
        logprob : array, shape (n_samples, n_components)
            Log probability of each sample in ``X`` for each of the
            model states.
        """

        n_samples = X.shape[0]
        llh = np.zeros((n_samples, self.n_components))

        f_s = [np.vectorize(partial(_compute_log_likelihood_per_state, nets=self.networks[s], pi_s=self.pi[s])\
                            , signature="(k)->()") for s in range(self.n_components)]

        # For each component
        for i, llh_fun in enumerate(f_s):
            llh[:, i] = llh_fun(X)

        return llh

    def _generate_sample_from_state(self, state, random_state=None):
        """Generates a random sample from a given component.

        Parameters
        ----------
        state : int
            Index of the component to condition on.

        random_state: RandomState or an int seed
            A random number generator instance. If ``None``, the object's
            ``random_state`` is used.

        Returns
        -------
        X : array, shape (n_features, )
            A random sample from the emission distribution corresponding
            to a given component.
        """


    def _initialize_sufficient_statistics(self):
        """Initializes sufficient statistics required for M-step.

        The method is *pure*, meaning that it doesn't change the state of
        the instance.  For extensibility computed statistics are stored
        in a dictionary.

        Returns
        -------
        nobs : int
            Number of samples in the data.

        start : array, shape (n_components, )
            An array where the i-th element corresponds to the posterior
            probability of the first sample being generated by the i-th
            state.

        trans : array, shape (n_components, n_components)
            An array where the (i, j)-th element corresponds to the
            posterior probability of transitioning between the i-th to j-th
            states.
        """
        stats = {'nobs': 0,
                 'start': np.zeros(self.n_components),
                 'trans': np.zeros((self.n_components, self.n_components))}
        return stats

    def _do_mstep(self, stats):
        """Performs the M-step of EM algorithm.

        Parameters
        ----------
        stats : dict
            Sufficient statistics updated from all available samples.
        """
        # The ``np.where`` calls guard against updating forbidden states
        # or transitions in e.g. a left-right HMM.
        if 's' in self.params:
            startprob_ = self.startprob_prior - 1.0 + stats['start']
            self.startprob_ = np.where(self.startprob_ == 0.0,
                                       self.startprob_, startprob_)
            normalize(self.startprob_)
        if 't' in self.params:
            transmat_ = self.transmat_prior - 1.0 + stats['trans']
            self.transmat_ = np.where(self.transmat_ == 0.0,
                                      self.transmat_, transmat_)
            normalize(self.transmat_, axis=1)



    def init_future(self):
        """
        Initialize dictionary which will store the updates during training.
        """
        self.future = dict([(k, self.__getattribute__(k)) for k in self.model_params])
        return self

    def apply_future(self):
        """
        Apply parameters calculated during a training iteration to the HMM object.
        """
        for attr, value in self.future.items():
            self.__setattr__(attr, value)
        return self

    def _draw_component(self, s):
        """
        Draw component for a given state, based on probability pi[s]

        Parameters
        ----------
        s: int, index of HMM state

        Returns
        -------
        k: int, index of component in state s
        """
        return np.random.choice(np.arange(self.n_components), 1, p=self.pi[s])[0]


def _compute_log_likelihood_per_state(x, nets=None, pi_s=None):
    out = [nets[k](x) for k in range(pi_s.shape[0])]
    llh_k = -np.array([o[1].detach().numpy()[0] for o in out])

    return (np.log(pi_s) + llh_k).sum()
